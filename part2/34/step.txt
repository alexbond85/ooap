34. Типичные проблемные особенности наследования
Наследование пред- и постусловий
Каждый класс реализует свой АТД: задаёт некоторое множество объектов, набор операций над ними, и семантику (пред- и постусловия). В ходе наследования предусловия могут ослабляться -- то есть любой пред-ослабленный метод в классе-потомке допускает применение в большем количестве случаев, нежели родительский. Усиливать же предусловия, соответственно, нельзя, иначе не будет соблюдаться спецификация родительского класса.
Например, если бы мы ошибочно сделали АТД BoundedStack (стек с ограниченым размером) наследником АТД Stack, то нам пришлось бы усилить предусловие операции push() в BoundedStack требованием учёта размера стека. Оригинальной версией push() мы пользоваться не смогли, и пришлось бы переопределить её реализацию. Но полиморфный объёкт S типа Stack может хранить объект класса BoundedStack, и при любом вызове S.push() подразумевается, что push() должен срабатывать всегда, но из-за усиления предусловия push() в классе-наследнике BoundedStack теперь вполне может возникнуть логическая ошибка вследствие неявного в данном случае ограничения на размер стека.
Это классический пример контринтуитивности правильного проектирования: хотя естественным выглядит наследование ограниченного стека от универсального стека, можно сделать наоборот, наследовать с расширением универсальный стек от ограниченного стека. Новая версия push() работает более универсально, нежели родительская, применима ко всем ситуациям, в которых применима и родительская push(), а также к ряду дополнительных.

Впрочем, возможен и другой вариант: добавить в АТД Stack запрос full() (так называемое абстрактное предусловие), который сигнализирует, полный ли стек. В Stack этот запрос всегда будет возвращать false, а АТД BoundedStack как наследник Stack переопределяет этот запрос уже с учётом реального размера.

Но в общем случае универсального решения для организации наследования между Stack и BoundedStack не находится, что показывает ограничение модели ООП.

Постусловия наоборот могут усиливаться -- то есть любой пост-усиленный метод, удовлетворяющий требованиям потомка, будет корректно применяться к объектам классов-предков. Он фактически предоставляет некоторый улучшенный результат. Но мы не можем ослаблять постусловия, иначе такое ослабление приведёт к существенному изменению (ухудшению) результата или состояния объекта, которое не специфицировано для родительского класса.

Например, постусловие для операции clear() в исходной версии стека с ограниченным количеством элементов (удалить N элементов) усиливается до удаления "всех" элементов (возможно, N, возможно, N*1000) в его потомке (универсальном стеке), и в этот усиленный, улучшенный вариант гарантированно входит и случай с удалением N элементов.

Это так называемый принцип подстановки Барбары Лисков из SOLID (Liskov Substitution Principle, LSP): потомки не должны "ломать" базовую логику, предоставляемую предками, но при этом должны обеспечивать полноценный интерфейс к этой базовой логике.

Задание 23.

Приведите словесный пример иерархии классов, и объясните, почему в ней нельзя ослаблять постусловия и усиливать предусловия.

повторить занятие сначала

Ссылку на ваше решение заданий на гитхабе введите в форму ниже: