14. Замыкание иерархии
Если система классов конкретного языка допускает множественное наследование, проектную иерархию желательно
замкнуть также и снизу: добавить пустой закрытый класс None, потомок всех классов. Все классы-листья (не
имеющие потомков) становятся прямыми предками None, и в итоге вся иерархия получается замкнутой снизу в форме
математической решётки.

В таком случае класс None начинает играть роль пустой ссылки void, которая эмулируется в некоторых языках
значением null/none. Добавлением класса None, который выступает аналогом отсутствия значения, мы остаёмся
полностью в рамках чистой объектной прикладной системы типов нашего проекта. Так как None потомок всех классов,
можно без ограничений использовать значение Void типа None в качестве значения переменной любого типа (класса),
добавив его в проект как стандартный глобальный объект.

Однако далеко не все современные языки поддерживают множественное наследование, поэтому, хотя подход с использованием
null заслуженно считается порочным, так как сильно ослабляет всю систему типов, вводя некоторую непонятную сущность
полностью за пределами этой системы, к использованию null всё же приходится прибегать.

К сожалению, это серьёзная уязвимость модели ООП, потому что даже наличие в проекте значения Void никак не страхует
от некорректной последовательности команд:

x = Void;
...
x.foo();
что приведёт к исключительной ситуации. В частных случаях можно добавлять проверки вида

if x == Void then ...
Однако общим решением будет только контроль исключительных ситуаций. Ответственность за правильную работу со
значениями Void/null в ООП полностью возлагается на программиста, система статической проверки типов тут
никак не поможет.

Задание 11.

Если используемый вами язык программирования допускает множественное наследование, постройте небольшую иерархию,
используя уже готовые General и Any, и замкните её снизу классом None. Приведите пример полиморфного
использования Void.