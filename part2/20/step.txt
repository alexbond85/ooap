20. Формальная модель ООП
Для объектно-ориентированного программирования в начале 1990-х годов была разработана формальная, математическая модель (Лука Карделли, сигма-исчисление). Немного более подробно мы познакомимся с ней на следующих курсах. В чём главная сила таких строгих, формальных подходов? В том, что они предлагают самый необходимый, очень ясный и прозрачный минимум абстракций, отбрасывающий кучу ненужных технических деталей и позволяющий гибко, мощно и очень компактно выражать весьма сложные концепции, что тем самым существенно снижает общую сложность создаваемой системы. При этом появляется возможность создания хорошо расширяемых и полностью децентрализованных архитектур, которые например реализуются моделью акторов, однако подход ООП, предлагаемый на данном курсе, потенциально как минимум не менее мощен.

В общем случае, вся проектная логика основывается только на одном базовом объектно-ориентированном синтаксисе:

x.f( arg )
x -- это объект (экземпляр конкретного типа);
f -- это либо оригинальный метод базового класса в иерархии, либо переопределённый метод в прямом классе объекта x, либо в одном из его предков;
arg -- это список аргументов метода f (возможно, пустой).

Статическая система типов автоматически проверяет корректность таких вызовов. Единственное исключение, если x -- полиморфный объект, и по каким-то причинам либо недопустим вызов самого метода f(), либо некорректен данный список аргументов для метода f() этого конкретного объекта, на который ссылается переменная x. Такое может случиться, например, если в коде ранее выполнялось полиморфное присваивание с явным приведением типа объекта к некоторому другому типу, что компилятор обычно допускает, перекладывая ответственность за последствия на программиста. Другой упоминавшийся случай -- использование "пустого" объекта Void.

