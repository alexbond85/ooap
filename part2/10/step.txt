10. Пример динамического связывания и полиморфизма
Например, у нас имеется иерархия из трёх классов (Универсальный список ParentList, связный список LinkedList и двухсвязный список TwoWayList), которую мы делали на первом курсе.

Объект p имеет тип ParentList, объект l -- тип LinkedList, и объект t -- тип TwoWayList. Тогда в программе разрешены так называемые полиморфные присваивания:

p = l
p = t
В переменную родительского класса записывается объект (ссылка на объект) дочернего класса.

Так как все объекты передаются по ссылке, в таком случае "изменение" типа объекта по своему смыслу подразумевает подмену некоторых методов, которые реально будут вызываться. Например, если переменная p хранит указатель на объект типа LinkedList, то при обращении p.right() будет вызван метод right() класса LinkedList, о чём разработчик заранее не знает. Объекты из данного и подобных примеров называются полиморфные -- их реальный тип может не совпадать с типом переменной, в которой они хранятся (фактически, в которую записана ссылка на соответствующий объект).

При этом надо иметь в виду возможную потерю информации: несмотря на то, что p хранит ссылку на объект типа TwoWayList, обращаться к методам класса TwoWayList напрямую мы не можем (если только не использовать явное приведение типов, что настоятельно не рекомендуется -- об этом будет рассказано далее). Однако такая потеря компенсируется динамическим связыванием, подразумевающим, что нужный метод полиморфного объекта будет определён динамически -- в зависимости от его реального типа в ходе работы программы.

Аналогичную семантику имеет и полиморфизм при передаче аргументов. Если конкретный язык программирования такое допускает, то в классе могут быть методы с одинаковыми именами, отличающиеся друг от друга типами каких-то аргументов. В таком случае выбор подходящего метода в процессе работы программы тоже происходит динамически и полиморфно.

