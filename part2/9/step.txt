9. Динамическое связывание
Наиболее глубокая и при этом достаточно абстрактная (универсальная) форма реализации отношения наследования (в общем случае повторного использования) -- это динамическое связывание. Программисту не требуется постоянно уточнять, метод какого конкретно типа (класса) должен быть вызван, он будет определён автоматически. Это очень важная возможность, которую мы никак не сможем получить, оставаясь в парадигме модулей -- ни универсализм, ни перегрузка операторов, и ничто иное.

Чем плохо статическое связывание? Если можно заранее, анализируя исходные тексты, автоматически определить, какой конкретно тип будет у полиморфного объекта в некотором случае, то эту работу должен выполнить компилятор, и только с целью оптимизации вызовов. Если же программист в такое связывание вкладывает другой смысл, нежели подразумевает компилятор, то это надо считать ошибкой. Так, если программист может выбирать политику статического связывания сам, то легко нарушить принцип открытости-закрытости: может потребоваться модификация класса, закрытого для изменений, которую заранее нельзя было предвидеть. Это можно решить переопределением нужного метода в классе-наследнике, однако если политика статического связывания возложена на программиста, то в таком случае вполне возможна ситуация, когда в предке не задана виртуальность соответствующего изменяемого метода, что потребует внесения правки в вышестоящий класс (уточнение сигнатуры метода), который уже закрыт для изменений. В разных языках эта проблема может проявляться по разному, например в Java все функции по умолчанию считаются виртуальными, а в С++ наоборот, невиртуальными.

В общем случае наследование позволяет создавать новые классы, которые и расширяют, и специализируют уже существующие классы. Это достигается с помощью трёх механизмов: переопределения в классе реализации методов его прямого предка, использования полиморфных объектов и динамического связывания.

При этом правильно спроектированный класс с точки зрения пользователя-программиста в идеале вообще не должен демонстрировать схему своего наследования. Наследование -- это внутренний механизм, и если полиморфизм в отношении класса не подразумевается, то и всю логику наследования для этого класса по возможности желательно скрыть. Такой класс, в отношении которого с точки зрения его пользователя наследование не применяется, называется плоским.

Во всех остальных случаях наследование требуется ровно в тех границах, которые обеспечивают необходимую логику полиморфизма и динамического связывания в проекте.

Задание 7.
Приведите пример кода с комментариями, где применяется динамическое связывание.