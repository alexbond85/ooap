6. Принципы повторного использования модуля
Полноценный механизм добавления в проект нового модуля, подразумевающего повторное
использование кода, должен отвечать всем пяти нижеприведённым принципам.

1. Новый модуль может задавать некоторый базовый тип, который потенциально должен
допускать параметризацию другими типами (обобщённые типы, типы-генерики);

2. Новый модуль может объединять несколько функций, которые активно обращаются друг к другу;

3. Новый модуль может входить в семейство модулей, ориентированных на решение некоторой
общей задачи, которую не удаётся решить с помощью одного модуля;

4. Новый модуль может предлагать конкретную реализацию родительского модуля,
которая должна выбираться динамически (полиморфно) -- например, реализация обобщённого типа для конкретного типа-параметра;

5. Новый модуль может интегрировать общее поведение нескольких модулей, которые различаются лишь деталями.

На практике выдерживать все эти правила не удаётся. Например, если попробовать использовать
механизм стандартных библиотек для реализации модулей, то окажется, что он подходит только
для достаточно простых проектов, когда имеются чёткие разграничения между спецификациями,
отсутствуют смысловые взаимосвязи, и все функции различаются и синтаксически, и семантически.
В лучшем случае удастся выполнить требования принципов 2, 3 и 5.

В некоторых языках поддерживаются пакеты со своими оригинальными именами, раздельной
компиляцией, публичным интерфейсом и скрытой реализацией. Пакеты в таком случае выступают
как абстрактные модули без реализации, однако тоже они не отвечают, в частности,
принципу 4 -- конкретную реализацию придётся выбирать самому программисту.

Возможность переопределения имён в модулях (и в частности, перегрузки операторов
для разных типов аргументов) частично хороша, но в целом плохо читабельна, не поддерживает
обобщённые типы, и главное, если у некоторых функций имеются различия в семантике,
то эти различия должны наглядно отражаться и на уровне синтаксиса, что перегрузка не позволяет по своей сути.

В ООП различаются термины "переопределение" (overridde) и "перегрузка" (overload).
Переопределение -- это перезапись логики родительского метода с точно такой же
сигнатурой в классе-потомке. Перегрузка -- когда в нескольких реализациях метода
внутри одного класса его имя одно и то же, а список аргументов различается.
Хотя в разных языках эти схемы могут и различаться.

Если же мы попробуем использовать шаблоны модулей, параметризованные
типами (когда одна и та же реализация применяется к различным видам объектов), то
получится фактически, что у нас имеется параметризованный типами открытый
универсальный модуль, но напрямую не применимый (потому что это шаблон), и
имеется условный набор его конкретных реализаций, закрытых для изменений (так как
поддержка параметризации встроена в язык). Это нарушает ключевой принцип
открытости-закрытости -- непонятно, как расширять такие шаблоны, не меняя уже использующий их код.

Задание 5.
Какие из пяти принципов повторного использования модуля поддерживаются в
используемом вами языке программирования?
(напомню, что пока речь идёт именно о модулях как базовой синтаксической единице, а не о классах)