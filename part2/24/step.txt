24. Изменяемость отношения is-a
Отношение "является" -- это всегда отношение между классами, между спецификациями, и никогда между объектами. "Является" может быть отношением только между абстрактными сущностями, между типами данных.

"Каждый гоночный автомобиль является обычным автомобилем" означает, что класс "гоночный автомобиль" наследуется от класса "обычный автомобиль". Это отношение задаётся статически на уровне системы типов программы, и его невозможно изменить в процессе её работы.

В случае отношения "содержит" утверждение "каждый гоночный автомобиль содержит двигатель" подразумевает, что объект "гоночный автомобиль А" содержит объект "двигатель Б" (например, в полиморфном поле в классе "гоночный автомобиль"), но во время работы программы вполне допускается, что "двигатель Б" будет динамически заменён на "двигатель В" допустимого типа.

Таким образом, первое правило выбора между "является" и "содержит" подразумевает, что если отношение похоже на "является", но тип наследуемого объекта по логике работы программы может меняться, то правильным отношением будет "содержит".

Например, "каждый гоночный автомобиль является обычным автомобилем" вполне корректно оформить как наследование, однако надо учитывать весь контекст проекта. В частности, могут добавляться принципиально новые классы "электрический автомобиль" или "летающий автомобиль", которые напрашивается сделать потомками класса "обычный автомобиль".
Однако от какого из них наследовать "гоночный автомобиль", если мы хотим сделать возможными гонки и для электромобилей, и для летающих машин, а множественное наследование в конкретном языке программирования запрещено? Наконец, если мы хотим оснастить гоночный автомобиль возможностями и электромобиля, и летающего автомобиля, как быть?

Можно расширять сам класс длинными списками атрибутов, и затем их интерпретировать в разных методах длинными цепочками проверок "если значение атрибута XYZ такое-то то ..." , но уже отмечалось, что это потребует модификации множества мест в коде при любом изменении логики таких проверок. Это верный признак ошибочного проектирования. Важно такие проверки выполнять статически на этапе компиляции, например через наследование или полиморфизм. Система типов в идеале не должна допускать ошибочных попыток использования сущностей на уровне синтаксиса программы.

В нашем случае "гоночный автомобиль" может наследоваться от общего класса "средство передвижения" с самыми универсальными характеристиками. Однако попытка смешения в иерархии понятий "электромобиль" и "летающий автомобиль" скорее всего ошибочна, и если даже летающий автомобиль имеет смысл делать потомком базового средства передвижения, непонятно, куда девать в такой иерархии "гоночный автомобиль". Такой проблемый вид наследования рассматривается далее, скорее всего возможность езды на электричестве стоит отнести к типу двигателя (сам двигатель как полиморфное поле включён в класс "средство передвижения"), а возможность полётов -- к некоторой технической специфике (ездить, летать, плавать).

Не исключено даже, что сам класс "гоночный автомобиль" стоит выделить в отдельную иерархию, независимую от "средства передвижения", которое включается в этот класс через отношение "содержит".

В целом, в таких случаях надо исходить из видения проекта в целом, и понимания, какие конкретно АТД будут требоваться. Тут стандартная рекомендация -- думать о классе всегда как о конкретной структуре данных со своим набором допустимых операций над ней, а внутренняя реализация полностью скрывается внутри класса.

Задание 17.

Приведите два словесных примера отношения "содержит" между классами, которое похоже на "является", но по вышеупомянутому правилу таковым не является.

повторить занятие сначала

