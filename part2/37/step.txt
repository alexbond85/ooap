37. Типичные проблемные особенности наследования-4
Конфликт с упорядоченным списком - 2
Например, мы могли бы оставить всё как есть: не выносить из родительского АТД ParentList сомнительные методы put_left, put_right, add_tail и replace, подразумевающие строгий порядок вставки значений (без учёта упорядоченности), а в комментарии к OrderedList просто уточнить, что на самом деле все эти четыре метода будут работать одинаково -- всегда помещать новое значение в нужную позицию автоматически. Но при этом существенно проиграет интуитивность интерфейса, что вполне может привести к неприятным ошибкам у пользователей такого класса.

Поэтому можно попробовать расширить нашу иерархию: добавить ещё один класс BaseList, из которого убрать все операции, связанные с явным порядком добавляемых значений. Но при этом потребуется новая операция put для добавления нового значения в список, потому что прежние операции put_left и put_right в своём названии подразумевали явный порядок вставки. В таком случае можно переименовать put_right в put, на уровне BaseList его не реализовывать, а логику работы (добавление следом за заданным значением) уточнить в комментариях к ParentList, хотя такая запутанность тоже сама по себе признак проблемы. Идея тут -- унаследовать обычный и двухсвязный списки от ParentList, а упорядоченный список -- от BaseList, и реализовать единственную операцию put.

Другой вариант -- реализовать SortedList как отдельный класс, и использовать внутри него TwoWayList как почти готовую реализацию (отношение "содержит"). Этот подход можно применять, когда SortedList -- практически гарантированное единичное исключение, и оригинальную иерархию списков ради такого исключения лучше не усложнять.

Классические минусы подхода has-a: во-первых, использование готового и достаточно универсального класса может понизить эффективность конкретной реализации, и во-вторых, везде потребуется использовать компонент (поле класса SortedList) типа TwoWayList, явно его указывая при вызове нужных методов. Это фактически привязка к конкретной реализации, а правильный поход -- ориентироваться только на публичный интерфейс, набор операций АТД.

Если недостатки данного подхода становятся слишком выраженными, лучше применять предыдущее решение, подразумевающее, что помимо SortedList могут быть и другие классы, которым требуется похожий интерфейс, и для организации универсальной обработки надо будет создать новый АТД.