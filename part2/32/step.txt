32. Наследование вида
Существует ещё один вид наследования -- наследование вида, который применяется в
сложных и неоднозначных ситуациях. Ранее упоминался важный принцип, по которому
надо стараться максимально избегать цепочек условных конструкций (проверок состояния
некоторого идентификатора во время работы программы) в пользу наследования (введения
отдельных классов для каждого состояния с поддержкой статических проверок типов).
Однако часто возникает ситуация, когда таких сущностей в классе несколько, и надо
их все как-то учесть совместно в одной иерархии, и при этом желательно избежать
множественного наследования.

Например, класс Сотрудник может характеризоваться как своей должностью из фиксированного
перечня (Программист, Инженер, Менеджер), так и формой рабочего соглашения (Постоянный
сотрудник, Контрактник, ...). Можно создать по классу на каждую из таких сущностей, и
все их сделать прямыми наследниками Сотрудника, но это неверный подход, так как две разные
семантические категории будут полностью перемешаны. Можно создать две иерархии, одна из
которых, например, Должность, будет объединять должности, а другая (Соглашение) формы
рабочих соглашений, и унаследовать конкретные классы уже от них. Такой подход называется
наследование видов (наследуются способы классификации класса-предка). Главный его
недостаток, что он требует множественного наследования, и кроме того, это достаточно
сложный способ проектирования иерархий.

Если множественное наследование не поддерживается, обычно выделяют один признак как
первичный -- на его основе и формируется иерархия. Однако задавать остальные признаки с
помощью перечислимых полей класса всё равно будет неверным. Например, мы выбрали Должность
как ключевой признак, и сделали Программиста, Инженера, Менеджера наследниками Сотрудника,
добавив в него целочисленное поле Contract, которое кодирует форму контракта. Это плохой
способ, нарушающий многие принципы ООП, потому что мы предполагаем необходимость цепочек
условных проверок значения этого поля и постоянной модификации кода многих классов в
случае расширения диапазона значений Contract.

