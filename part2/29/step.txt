29. Категории наследования-2
4) Наследования вариаций
Это семейство категорий наследования подразумевает переопределение методов родительских классов без добавления новых компонентов (если они только не будут обязательным следствием такого переопределения).

Наследование с функциональной вариацией (functional variation inheritance) подразумевает переопределение родительского метода без изменения его сигнатуры (переопределяется только логика работы).

Наследование с вариацией типа (type variation inheritance) подразумевает переопределение сигнатуры родительского метода (так называемая перегрузка метода).

Как правило, данная категория наследования применяется, когда требуется для каких-то операций реализовать логику, явно отличающуюся от логики класса-предка. Это например рассмотренный выше случай, когда мы создавали два дополнительных класса Male и Female, в каждом из которых реализовывалась особая логика некоторых методов класса-родителя Human в зависимости от конкретного пола человека. Кроме того, такие подходы могут потребоваться, когда родительский класс закрыт для изменений.

Как правило, эти виды наследования в конкретных языках программирования подразумевают указание дополнительных модификаторов для сигнатур методов, уточняющих схему их переопределения или перегрузки.

5) Наследование с конкретизацией (reification inheritance)
Это классическая схема "наследования кода", когда реализация общего родительского класса отложена (он абстрактный, например, или реализован частично), а конкретные законченные реализации выполнены в его классах-наследниках. Под конкретизацией здесь понимается "превращение абстракции в вещь".

6) Структурное наследование (structure inheritance)
Данный вид наследования нередко реализуется в языках программирования в виде интерфейсов. Структурное наследование подразумевает добавление типу данных некоторого нового, автономного, формального свойства. Например, класс SortedList, наследник класса List, которому дополнительно требуется учёт отношения порядка между строками, может также наследовать класс Comparable (или интерфейс, если множественное наследование запрещено).

Отличие данного вида наследования от конкретизации в том, что конкретизация семантически связана с родительским типом, а структурное наследование подразумевает добавление качественно новой абстракции.

Тут периодически возникает ошибка новичка, когда структурное наследование путают с отношением "является" is-a. Различие тут явное и формальное: если наследование структурное, то наследуемое свойство относится к классу как внешнему и единому целому. Например, отношение порядка применительно к классу Автомобиль подразумевает возможность сравнения самих автомобилей в целом. А отношение "является" подразумевает наследование свойств, непосредственно присущих родительскому объекту (например, наследование атрибута Двигатель). При этом само отношение между Автомобиль и Двигатель -- это не наследование, а has-a, "содержит".

Типичный пример структурного наследования -- это реализация итерирования, механизма перебора элементов массива или списка. Тут обычно предлагается большое множество различных полезных операций, например, переход к следующему элементу с сохранением текущей позиции в массиве, или поиск первого элемента, удовлетворяющего некоторому предикату, который может быть функцией (при том, что далеко не все языки позволяют передавать функцию как параметр).

Мы реализовали для списков простейшую схему итератора (концепция курсора) на первом курсе, однако стоит ли её встраивать в сами классы списков? Ведь у нас может быть много разных структур данных, которым полезна итерация (например, массивы, текстовые документы, и вообще любые структуры данных, для которых имеет смысл понятие следования элементов друг за другом). И в каждом таком случае реализовывать итераторы очень похожим кодом весьма нежелательно. Тут как раз хорошо работает ковариантность (автоматическая параметризация логики разными типами данных).

Более того, сами итераторы можно расширить и на более сложные структуры данных (например, деревья), что подразумевает их собственную организацию в иерархию классов. Насколько понятие "итератор" подходит для реализации в виде отдельного АТД, подразумевающего абстрактную, но вполне конкретную структуру данных? Один из видов классических структур данных -- это так называемая абстрактная вычислительная машина. Она представляет собой вполне конкретный объект, содержащий набор операций, которые можно применять к определённому типу данных. И в данном примере итератор как абстрактная машина вполне подлежит выделению в отдельный класс.

Задание 20.

Приведите примеры кода, реализующие наследование вариаций, наследование с конкретизацией и структурное наследование.

повторить занятие сначала

Ссылку на ваше решение заданий на гитхабе введите в форму ниже: