21. Ограничения ООП
Глобальная проблема ООП в том, что крайне сложно создать язык с разумными прикладными возможностями, в котором любая синтаксически корректная конструкция будет автоматически корректной и в рамках статической системы типов такого языка. Поэтому приходится вводить правила, договорённости, ограничивающие синтаксическую свободу кодирования ради сохранения корректности системы в целом.

Одно из таких правил -- полный отказ от явного приведения типов в программе, как минимум в отношении пользовательской иерархии классов.

Ещё более строгое правило -- определить допустимый набор, множество типов, с которыми полиморфному объекту некоторого класса разрешается связываться во время работы программы. Такое множество может быть строже, нежели допускает полиморфизм -- например, это могут быть не все классы-предки, а только некоторые.

Стандартное полиморфное присваивание

x = y
подразумевает, что класс объекта y принадлежит множеству допустимых типов для переменной x (начиная с её класса, и ниже по иерархии), и очень хорошо, если язык программирования позволяет накладывать на такое присваивание (на содержимое допустимого множества типов) дополнительные ограничения.

Компилятор это может выполнить, например, изучив все полиморфные присваивания в исходном коде, составив списки конкретных типов объектов из правой части для типа переменной из левой части, и разрешив в процессе работы программы только соответствующие полиморфные преобразования. По аналогичной схеме учитывают также полиморфные вызовы методов, у которых типы формальных и фактических параметров могут отличаться.

В конечном итоге такой алгоритм -- процесс выделения связанных множеств типов в конечном коде -- обязательно заканчивается, и называется он метод неподвижной точки. Его реализация может быть весьма трудоёмкой, потому что содержимое множеств типов начинает зависеть от порядка встречаемых полиморфных вызовов, и в общем случае требуется несколько проходов, более глубокий анализ кода, и сложность алгоритма быстро растёт. На практике используются более простые пессимистичные подходы, не допускающие излишней полиморфной гибкости, если она не выводится из кода достаточно просто.