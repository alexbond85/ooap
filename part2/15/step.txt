15. Попытка присваивания
Довольно массовая проблема в проектировании иерархии классов связана с необходимостью
проверять реальный тип полиморфного объекта и выполнять те или иные действия в зависимости
от его типа, с помощью цепочки условных конструкций. Например, в предыдущем разделе мы
делали условную проверку, по сути, типа объекта на его "пустотность" -- сравнивали с единственным
значением Void типа None. Ещё одна частая ситуация, приводящая к таким цепочкам, возникает,
когда некоторые данные поступают в программу в сыром формате, и если подразумевается, что они
должны десериализоваться в объект типа T, на практике тип (структура этих данных) может быть
совсем другим (например, по ошибке пришли не те данные, или они испортились).

Наличие в программе проверок наподобие

if type(object) is LinkedList then ...
else if type(object) is TwoWayList then ...
верный признак плохого проектирования. Во-первых, подобные цепочки могут расплодиться по всему
проекту, и при добавлении нового типа придётся каждый раз править их все. Во-вторых, само по себе
сравнение типов в рамках формальной модели ООП крайне плохая идея -- в идеале, в ООП не должно
быть вообще никаких динамических операций работы с типами, соответствующая логика проверок корректности
типов должна выполняться статически, компилятором. То есть ни при каких условиях мы не должны делать
дополнительных проверок типа, если код успешно прошёл проверку компилятором (тайп-чекинг).

Ситуация облегчается тем, что на практике мы обычно представляем, какой примерно тип объекта ожидается.
Поэтому все цепочки проверок типов из кода полностью исключаются, а инструкции обычного присваивания
некоторой переменной типа T полиморфного объекта (присваивания ссылки на этот другой объект,
предположительно, одного из типов-потомков, совместимых с T) заменяются на свою более ограниченную версию.

Формальная модель ООП предлагает для всех подобных случаев так называемую попытку присваивания,
которую можно оформить как команду:

assignment_attempt(target, source)
Если тип source совместим с типом target, то присваивание выполняется успешно, в противном случае переменной
target присваивается значение Void. Принципиальный момент, что такой случай не расценивается как
ошибочный -- в отличии от многих популярных языков, где в таком случае возникает исключение. При желании можно
выдавать особый статус такой команды, однако не следует его трактовать как ошибку -- причина такой ситуации
будет прежде всего в неверных архитектурных подходах.

Задание 12.

Добавьте в классы General и Any попытку присваивания и её реализацию.