17. Наследование, полиморфизм и обобщённые типы
Наследование с полиморфизмом объединяются в полиморфных структурах данных, которые мы можем дополнительно
параметризовать отдельным типом T (например, MyType<T>). При этом подразумевается, что реальным параметром
при создании конкретного объекта типа MyType<T> можно задавать не только тип T, но и любой его потомок.

В ряде случаев желательно, чтобы над типом T можно было выполнять некоторые операции, которые семантически
присущи типу MyType. Если мы определяем некоторую операцию над типом MyType (например, сложение), то
естественно было бы уметь складывать и значения типа T. Если MyType -- это скалярный массив, и T -- целый тип,
то сложение двух массивов целых чисел естественно было бы описать как сложение их соответствующих
элементов (целых значений). Но для этого требуется, чтобы сложение допускалось и для значений типа T.
Другие стандартные виды таких операций, которые хотелось бы переносить и на тип-параметр T -- это
например сортировка (проверка отношения порядка), вычисление хэш-ключа, и т. д.

Но по умолчанию о типе T мы ничего не знаем. Максимум, что о нём известно -- это то, что тип T есть потомок
типа Any. Поэтому решение здесь достаточно простое и называется ограниченной универсальностью: так как мы
всегда остаёмся в рамках нашей системы типов, используем только классы из иерархии, то для соответствующих
нужд определяем промежуточные классы, которые поддерживают требуемое множество операций. Эффективнее всего
этот момент решается с помощью множественного наследования, но если таких разных наборов операций много,
и наследовать их друг от друга некорректно (они совсем разные по смыслу), приходится изобретать "кривые"
решения наподобие интерфейсов, композиции и т. д.

При использовании ограниченной универсальности надо учитывать, что тип-параметр T должен быть
потомком класса с подходящим набором операций. Например, если мы захотим определить список списков
целых чисел, LinkedList<LinkedList<Integer>>, над которым допустима операция сложения
списков (когда каждый результирующий элемент списка будет представлять собой связный список,
равный сумме связных списков соответствующих аргументов), то в идеале требуется, чтобы и Integer, и
LinkedList были потомками некоторого класса, допускающего операции сложения. Если множественное
наследование в языке отсутствует, реализовать это можно, например, добавив операцию сложения в
класс Any, раз уж она так актуальна для всей системы типов.

Задание 14.

Сформируйте тип (класс) Vector<T> (линейный массив значений типа T, наследуемого от General), над
которым допустима операция сложения, реализуемая как сложение соответствующих значений типа T двух
векторов одинаковой длины. Если длины векторов различны, возвращайте Void/null в качестве
результата работы операции сложения.

Выясните, как в используемом вами языке программирования элегантнее всего реализовать поддержку
сложения элементов произвольных типов.
Проверьте, насколько корректно будет работать сложение объектов типа Vector<Vector<Vector<T>>>.