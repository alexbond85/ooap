8. Класс как тип
Во взгляде на класс как на тип мы пытаемся совместить принцип повторного использования кода с расширяемостью, которой не удалось полноценно достичь с помощью модулей. И ключевым в таком подходе к наследованию становится полиморфизм и динамическое связывание.

Посмотрим на отношение класс как тип относительно связываемых значений (объектов) как на отношение включения множеств. Например, множество всех объектов "Двухсвязный список" во время работы программы является подмножеством множества всех объектов "Универсальный список". Причём эти два типа не обязательно наследуются напрямую, между ними может быть цепочка промежуточных типов.

Если же посмотреть на это отношение относительно операций над соответствующими типами (по сути, как на отношение между АТД), то отношение "каждый двухсвязный список является универсальным списком" означает, что любая операция, применимая к родительскому универсальному списку, применима также и к дочернему двухсвязному списку (с учётом того, что эти операции могут быть переопределены в двухсвязном списке), но не наоборот.

То есть в случае "класс как тип" мы получаем не расширение родительского класса, а специализацию, что прямо противоположно подходу "класс как модуль".

В результате на практике появляются подобные частые ошибки: "двухсвязный список my_list_007 в моём коде является универсальным списком". Тут используется отношение между значением и категорией, что неверно. Отношение "является" всегда выражает отношение только между категориями (типами, классами). Например, всякий АТД "Двухсвязный список" является АТД "Универсальный список".

Какой из этих подходов более правильный для понимания принципа наследования? Как может быть разрешён парадокс расширения-специализации? Фактически получается, что чем больше у нас различных типов в цепочке наследования, тем к меньшему количеству объектов они могут применяться, так как мы движемся вниз по иерархии в направлении специализации.

Поэтому в частности, некорректно применение массово распространённого термина "подкласс" и в смысле подмножества, и в смысле наследования. Правильно использовать только такие термины: наследник и родитель, потомок и предок, прямой/собственный потомок и предок.