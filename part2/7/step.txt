7. Разбираемся с модульным противоречием
Выход из противоречивой модели модуля находится в парадигме ООП. Классические попытки совместить все пять принципов с помощью модулей, компонентов, пакетов, терпят неудачу.

Тема декомпозиции проекта на небольшие автономные сущности изучается в программной инженерии не менее полувека. Идея модулей строится вокруг набора функций, вокруг парадигмы так называемого структурного программирования, а ООП -- вокруг объекта. Это вечные попытки как-то более-менее эффективно разрешить конфликт между данными и функциями/методами их обработки. Подробно тему декомпозиции, построения модели предметной области, проектирования качественной иерархии классов, изучаем на следующем курсе. Пока мы приближаемся к идее, что класс (с использованием наследования и полиморфизма) представляется наиболее оптимальной формой модуля. Только надо всегда помнить, когда мы выполняем декомпозицию, то выделяем классы таким образом, что они представляют собой не просто наборы функций, а прежде всего некоторые структуры данных, которые хоть и описываются только операциями, однако все эти операции имеют семантическое отношение именно к своей структуре данных.

Основа объектно-ориентированного подхода -- это приоритет типов данных над описывающими их операциями. То есть в списке методов класса, который всегда задаёт некоторую структуру данных, не должно быть методов, не имеющих прямого отношения к этой структуре данных.

Задание 6.
Существуют ли ситуации, когда связи между модулями должны делаться публичными?
Какие метрики вы бы предложили для количественной оценки принципов организации модулей?
Если вы разрабатывали программы, в которых было хотя бы 3-5 классов, как бы вы оценили их модульность по этим метрикам?

повторить занятие сначала

Ссылку на ваше решение заданий на гитхабе введите в форму ниже:

