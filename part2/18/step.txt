18. Как расширять иерархию новыми классами
В каких случаях надо расширять иерархию классов, как правильно это делать?

Добавление нового класса как потомка некоторого класса имеет смысл, если этот потомок либо переопределяет какие-либо наследуемые методы, либо расширяет его новыми методами.

Но это правило связано с реализацией, а главный принцип остаётся прежним -- любой класс это всегда реализация соответствующей спецификации АТД (полная или частичная). Любой класс в иерархии реализует свой АТД, и каждый АТД представляет собой оригинальную конкретную структуру данных со своим набором операций, и добавляется он прежде всего в техническое задание, в общую модель системы. В частности, если в проекте потребовалась сущность, для которой надо изменить пред- и постусловия некоторого АТД, значит, надо добавить потомок этого АТД с переопределением соответствующих запросов или команд.

Существует, пожалуй, единственное исключение, когда можно включать новый класс, не добавляющий ничего нового -- когда иерархия точно отражает некоторую предметную область, и в ней приняты соответствующие частные случаи как самостоятельные сущности, однако отдельные АТД им не нужны, достаточно добавить класс лишь как новый синтаксический элемент. И всё равно такой практике надо максимально сопротивляться.

Классический пример конфликта таксономии (теории классификации), встречающийся сегодня очень часто -- это расширение класса, описывающего какой-то аспект человека (например, Human или Sportsman), его полом. Обычно такое расширение выполняется добавлением булева атрибута female, после чего во многих местах кода начинают появляться проверки if female then ...

Это, как уже говорилось, верный признак плохого проектирования. Как только такие цепочки проверок начинают размазываться по всему проекту, возникает риск забыть исправить одну из них в случае модификации соответствующей логики -- например, когда количество вариантов существенно увеличится. Сегодня в некоторых странах допускается больше чем два значения пола, а всего их насчитывается уже более пятидесяти, и эта проблема схожа с проблемой Y2K, когда под хранение года в 20-м веке отводилось не четыре цифры, а только две последние.

